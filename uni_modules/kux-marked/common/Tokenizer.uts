import { _defaults } from './defaults';
import {
	rtrim,
	splitCells,
	findClosingBracket,
	trimStart,
	trimEnd,
} from './helpers';
import { Rules, I_Lexer, Links, Tokens, Token, MarkedOptions, InlineLink, I_Tokenizer, Blockquote, Br, Code, Codespan, Def, Del, Em, Escape, HTML, Hr, Link, List, ListItem, Paragraph, Space, Strong, Table, Tag, Text, Image, TableCell, MarkedToken, Heading, NodesToken } from '../utssdk/interface';

// // #ifdef APP-ANDROID
// import JSReg from 'io.dcloud.uts.jsreg.JSReg';
// // #endif

function outputLink(cap : string[], link : NodesToken, raw : string, lexer : I_Lexer, rules : Rules) : NodesToken {
	const href = link.href;
	const title = link.title ?? null;
	const text = cap[1].replace(rules.other.outputLinkReplace, '$1');

	if (cap[0].charAt(0) != '!') {
		lexer.state.inLink = true;
		const token = {
			type: 'link',
			raw,
			href,
			title,
			text,
			tokens: lexer.inlineTokens(text, [] as NodesToken[])
		} as NodesToken;
		lexer.state.inLink = false;
		return token;
	}
	return {
		type: 'image',
		raw,
		href,
		title,
		text,
		tokens: lexer.inlineTokens(text, [] as NodesToken[])
	} as NodesToken;
}

function indentCodeCompensation(raw : string, text : string, rules : Rules) : string {
	const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);

	if (matchIndentToCode == null) {
		return text;
	}

	const indentToCode = matchIndentToCode[1] ?? '';

	return text
		.split('\n')
		.map((node) => {
			const matchIndentInNode = node.match(rules.other.beginningSpace);
			if (matchIndentInNode == null) {
				return node;
			}
			const indentInNode = matchIndentInNode[0] ?? '';
			if (indentInNode.length >= indentToCode.length) {
				return node.slice(indentToCode.length);
			}
			return node;
		})
		.join('\n');
}

/**
 * Tokenizer
 */
export class Tokenizer implements I_Tokenizer {
	options! : MarkedOptions;
	rules : Rules | null = null;
	lexer : I_Lexer | null = null;

	constructor(options : MarkedOptions | null = null) {
		this.options = options ?? _defaults;
	}

	space(src : string) : NodesToken | null {
		const cap = this.rules!.block.newline.exec(src);
		if (cap != null && cap[0] != null && cap[0]!.length > 0) {
			return {
				type: 'space',
				raw: cap[0]!,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}

		return null;
	}

	code(src : string) : NodesToken | null {
		const cap = this.rules!.block.code.exec(src);
		if (cap != null && cap[0] != null) {
			const text = cap[0]!.replace(this.rules!.other.codeRemoveIndent, '');
			return {
				type: 'code',
				raw: cap[0]!,
				codeBlockStyle: 'indented',
				text: this.options.pedantic == false || this.options.pedantic == null
					? rtrim(text, '\n', null)
					: text,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}
		return null;
	}

	fences(src : string) : NodesToken | null {
		if ((this.rules!.block.fences instanceof RegExp) == false) {
			return null;
		}
		// #ifndef APP-HARMONY
		const cap = (this.rules!.block.fences as RegExp).exec(src);
		// #endif
		// #ifdef APP-HARMONY
		const cap = /^ {0,3}(`{3,}|~{3,})([^\n]*)\n([\s\S]*?)\n {0,3}\1 *(?:\n|$)/.exec(src);
		// #endif
		if (cap != null && cap[0] != null) {
			const raw = cap[0];
			const text = indentCodeCompensation(raw!, cap[3] ?? '', this.rules!);

			return {
				type: 'code',
				raw: raw!
				lang: cap[2] != null ? cap[2]!.trim().replace(this.rules!.inline.anyPunctuation, '$1') : cap[2],
				text,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}

		return null;
	}

	heading(src : string) : NodesToken | null {
		const cap = this.rules!.block.heading.exec(src);
		if (cap != null && cap[0] != null) {
			let text = cap[2]!.trim();
			// remove trailing #s
			if (this.rules!.other.endingHash.test(text)) {
				const trimmed = rtrim(text, '#', null);
				if (this.options.pedantic == true) {
					text = trimmed.trim();
				} else if (trimmed.length == 0 || this.rules!.other.endingSpaceChar.test(trimmed)) {
					// CommonMark requires space before trailing #s
					text = trimmed.trim();
				}
			}

			return {
				type: 'heading',
				raw: cap[0]!,
				depth: cap[1]!.length,
				text: text,
				tokens: this.lexer!.inline(text, [] as NodesToken[])
			} as NodesToken;
		}

		return null;
	}

	hr(src : string) : NodesToken | null {
		const cap = this.rules!.block.hr.exec(src);
		if (cap != null && cap[0] != null) {
			return {
				type: 'hr',
				raw: rtrim(cap[0]!, '\n', null),
				tokens: [] as NodesToken[]
			};
		}

		return null;
	}

	blockquote(src : string) : NodesToken | null {
		const cap = this.rules!.block.blockquote.exec(src);
		if (cap != null && cap[0] != null) {
			let lines = rtrim(cap[0]!, '\n', null).split('\n');
			let raw = '';
			let text = '';
			const tokens : NodesToken[] = [] as NodesToken[];

			while (lines.length > 0) {
				let inBlockquote = false;
				const currentLines = [] as string[];

				let i = 0;
				for (i = 0; i < lines.length; i++) {
					// get lines up to a continuation
					if (this.rules!.other.blockquoteStart.test(lines[i])) {
						currentLines.push(lines[i]);
						inBlockquote = true;
					} else if (!inBlockquote) {
						currentLines.push(lines[i]);
					} else {
						break;
					}
				}
				lines = lines.slice(i);

				const currentRaw = currentLines.join('\n');
				const currentText = currentRaw
					// precede setext continuation with 4 spaces so it isn't a setext
					.replace(this.rules!.other.blockquoteSetextReplace, '\n    $1')
					.replace(this.rules!.other.blockquoteSetextReplace2, '');

				raw = raw != null ? `${raw}\n${currentRaw}` : currentRaw;
				text = text != null ? `${text}\n${currentText}` : currentText;

				// parse blockquote lines as top level tokens
				// merge paragraphs if this is a continuation
				const top = this.lexer!.state.top;
				this.lexer!.state.top = top;
				this.lexer!.blockTokens(currentText, tokens, true);
				this.lexer!.state.top = top;

				// if there is no continuation then we are done
				if (lines.length == 0) {
					break;
				}

				const lastToken = tokens[tokens.length - 1] as MarkedToken;

				if (lastToken.type == 'code') {
					// blockquote continuation cannot be preceded by a code block
					break;
				} else if (lastToken.type == 'blockquote') {
					// include continuation in nested blockquote
					const oldToken = lastToken as Blockquote;
					const newText = oldToken.raw + '\n' + lines.join('\n');
					const newToken = this.blockquote(newText);
					if (newToken != null) {
						tokens[tokens.length - 1] = newToken;
					}

					if ((raw.length - oldToken.raw.length) <= raw.length) {
						raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken?.raw ?? '';
					} else {
						raw = '';
					}
					if ((text.length - oldToken.text.length) <= text.length) {
						text = text.substring(0, text.length - oldToken.text.length) + newToken?.text ?? '';
					} else {
						text = '';
					}
					break;
				} else if (lastToken.type == 'list') {
					// include continuation in nested list
					const oldToken = lastToken;
					const newText = oldToken.raw + '\n' + lines.join('\n');
					const newToken = this.list(newText);
					if (newToken != null) {
						tokens[tokens.length - 1] = newToken;
					}

					if ((raw.length - oldToken.raw.length) <= raw.length) {
						raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken?.raw ?? '';
					} else {
						raw = '';
					}
					if ((text.length - oldToken.raw.length) <= text.length) {
						text = text.substring(0, text.length - oldToken.raw.length) + newToken?.raw ?? '';
					} else {
						text = '';
					}
					const tokenObj = JSON.parseObject(JSON.stringify(tokens[tokens.length - 1]))!
					if (`${tokenObj['raw']}`.length <= newText.length) {
						lines = newText.substring(`${tokenObj['raw']}`.length).split('\n');
					} else {
						lines = [] as string[];
					}
					continue;
				}
			}

			return {
				type: 'blockquote',
				raw,
				tokens,
				text
			} as NodesToken;
		}

		return null;
	}

	private _transformToken(token : NodesToken) : UTSJSONObject {
		return JSON.parseObject(JSON.stringify(token)!)!;
	}

	list(src : string) : NodesToken | null {
		let cap = this.rules!.block.list.exec(src);
		if (cap != null && cap[0] != null) {
			let bull = cap[1]!.trim();
			const isordered = bull.length > 1;

			const list = {
				type: 'list',
				raw: '',
				ordered: isordered,
				start: isordered ? bull.slice(0, -1) : '',
				loose: false,
				items: [] as NodesToken[],
				tokens: [] as NodesToken[]
			} as NodesToken;

			bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;

			if (this.options.pedantic == true) {
				bull = isordered ? bull : '[*+-]';
			}

			// Get next list item
			const itemRegex = this.rules!.other.listItemRegex(bull);
			let endsWithBlankLine = false;
			// Check if current bullet point can start a new List Item
			while (src.length > 0) {
				let endEarly = false;
				let raw = '';
				let itemContents = '';
				cap = itemRegex.exec(src);
				if (cap == null) {
					break;
				}

				if (this.rules!.block.hr.test(src)) {
					// End list if bullet was actually HR (possibly move into itemRegex?)
					break;
				}

				raw = cap[0]!;
				if (raw.length <= src.length) {
					src = src.substring(raw.length);
				} else {
					src = '';
				}

				let line = cap[2]!.split('\n', 1)[0].replace(this.rules!.other.listReplaceTabs, (t : string, offset : number, string : string) => ' '.repeat(3 * t.length));
				let nextLine = src.split('\n', 1)[0];
				let blankLine = line.trim().length == 0;

				let indent = 0;
				if (this.options.pedantic == true) {
					indent = 2;
					itemContents = trimStart(line);
				} else if (blankLine) {
					indent = cap[1]!.length + 1;
				} else {
					indent = cap[2]!.search(this.rules!.other.nonSpaceChar); // Find first non-space char
					indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
					itemContents = line.slice(indent);
					indent += cap[1]!.length;
				}

				if (blankLine && this.rules!.other.blankLine.test(nextLine)) { // Items begin with at most one blank line
					raw += nextLine + '\n';
					if ((nextLine.length + 1) <= src.length) {
						src = src.substring(nextLine.length + 1);
					} else {
						src = '';
					}
					endEarly = true;
				}

				if (!endEarly) {
					const nextBulletRegex = this.rules!.other.nextBulletRegex(indent);
					const hrRegex = this.rules!.other.hrRegex(indent);
					const fencesBeginRegex = this.rules!.other.fencesBeginRegex(indent);
					const headingBeginRegex = this.rules!.other.headingBeginRegex(indent);
					const htmlBeginRegex = this.rules!.other.htmlBeginRegex(indent);

					// Check if following lines should be included in List Item
					while (src.length > 0) {
						const rawLine = src.split('\n', 1)[0];
						let nextLineWithoutTabs = '';
						nextLine = rawLine;

						// Re-align to follow commonmark nesting rules
						if (this.options.pedantic == true) {
							nextLine = nextLine.replace(this.rules!.other.listReplaceNesting, '  ');
							nextLineWithoutTabs = nextLine;
						} else {
							nextLineWithoutTabs = nextLine.replace(this.rules!.other.tabCharGlobal, '    ');
						}

						// End list item if found code fences
						if (fencesBeginRegex.test(nextLine)) {
							break;
						}

						// End list item if found start of new heading
						if (headingBeginRegex.test(nextLine)) {
							break;
						}

						// End list item if found start of html block
						if (htmlBeginRegex.test(nextLine)) {
							break;
						}

						// End list item if found start of new bullet
						if (nextBulletRegex.test(nextLine)) {
							break;
						}

						// Horizontal rule found
						if (hrRegex.test(nextLine)) {
							break;
						}

						if (nextLineWithoutTabs.search(this.rules!.other.nonSpaceChar) >= indent || nextLine.trim().length == 0) { // Dedent if possible
							itemContents += '\n' + nextLineWithoutTabs.slice(indent);
						} else {
							// not enough indentation
							if (blankLine) {
								break;
							}

							// paragraph continuation unless last line was a different block level element
							if (line.replace(this.rules!.other.tabCharGlobal, '    ').search(this.rules!.other.nonSpaceChar) >= 4) { // indented code block
								break;
							}
							if (fencesBeginRegex.test(line)) {
								break;
							}
							if (headingBeginRegex.test(line)) {
								break;
							}
							if (hrRegex.test(line)) {
								break;
							}

							itemContents += '\n' + nextLine;
						}

						if (!blankLine && nextLine.trim().length == 0) {
							blankLine = true;
						}

						raw += rawLine + '\n';
						if ((rawLine.length + 1) <= src.length) {
							src = src.substring(rawLine.length + 1);
						} else {
							src = '';
						}
						// src = src.substring(rawLine.length + 1);
						line = nextLineWithoutTabs.slice(indent);
					}
				}

				if (list.loose != true) {
					// If the previous item ended with a blank line, the list is loose
					if (endsWithBlankLine) {
						list.loose = true;
					} else if (this.rules!.other.doubleBlankLine.test(raw)) {
						endsWithBlankLine = true;
					}
				}

				let istask : RegExpExecArray | null = null;
				let ischecked : boolean = false;
				// Check for task list items
				if (this.options.gfm != null) {
					istask = this.rules!.other.listIsTask.exec(itemContents);
					if (istask != null) {
						ischecked = istask[0] !== '[ ] ';
						itemContents = itemContents.replace(this.rules!.other.listReplaceTask, '');
					}
				}

				list.items!.push({
					type: 'list_item',
					raw,
					task: istask != null,
					checked: ischecked,
					loose: false,
					text: itemContents,
					tokens: [] as NodesToken[],
				} as NodesToken);

				list.raw += raw;
			}

			// Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
			const lastItem = list!.items![list.items!.length - 1];
			if (lastItem != null) {
				lastItem.raw = trimEnd(lastItem.raw as string);
				lastItem.text = trimEnd(lastItem!.text as string);
			} else {
				// not a list since there were no items
				return null;
			}
			list.raw = trimEnd(list.raw as string);

			// Item child tokens handled here at end because we needed to have the final item to trim it first
			for (let i = 0; i < list.items!.length; i++) {
				this.lexer!.state.top = false;
				list.items![i].tokens = this.lexer!.blockTokens(list.items![i].text as string, [] as NodesToken[], null) as NodesToken[];

				if (list.loose != true) {
					// Check if list should be loose
					const spacers = (list.items![i]!.tokens!).filter(t => t.type == 'space');
					const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules!.other.anyLine.test(`${this._transformToken(t)['raw']}`));

					list.loose = hasMultipleLineBreaks;
				}
			}

			// Set all items to loose if list is loose
			if (list.loose == true) {
				for (let i = 0; i < list.items!.length; i++) {
					list.items![i].loose = true;
				}
			}

			return list;
		}

		return null;
	}

	html(src : string) : NodesToken | null {
		const cap = this.rules!.block.html.exec(src.toLowerCase());
		if (cap != null && cap[0] != null) {
			const token = {
				type: 'html',
				block: true,
				raw: cap[0]!,
				pre: cap[1] == 'pre' || cap[1] == 'script' || cap[1] == 'style',
				text: cap[0]!,
				tokens: [] as NodesToken[]
			} as NodesToken;
			return token;
		}
		return null;
	}

	def(src : string) : NodesToken | null {
		const cap = this.rules!.block.def.exec(src);
		if (cap != null) {
			const tag = cap[1]!.toLowerCase().replace(this.rules!.other.multipleSpaceGlobal, ' ');
			const href = cap[2] != null && cap[2]!.length > 0 ? cap[2]!.replace(this.rules!.other.hrefBrackets, '$1').replace(this.rules!.inline.anyPunctuation, '$1') : '';
			const title = cap[3] != null && cap[3]!.length > 0 ? cap[3]!.substring(1, cap[3]!.length - 1).replace(this.rules!.inline.anyPunctuation, '$1') : cap[3];
			return {
				type: 'def',
				tag,
				raw: cap[0] ?? '',
				href,
				title: title ?? '',
				tokens: [] as NodesToken[]
			} as NodesToken;
		}

		return null;
	}

	table(src : string) : NodesToken | null {
		if (this.rules!.block.table instanceof UTSJSONObject) {
			return null;
		}
		const cap = (this.rules!.block.table as RegExp).exec(src);
		if (cap == null) {
			return null;
		}
		if (!this.rules!.other.tableDelimiter.test(cap[2]!)) {
			// delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
			return null;
		}

		const headers = splitCells(cap[1]!, null);
		const aligns = `${cap[2]}`.replace(this.rules!.other.tableAlignChars, '').split('|');
		let rows = [] as string[];
		if (cap[3] != null && cap[3]!.length != 0) {
			rows = cap[3]!.replace(this.rules!.other.tableRowBlankLine, '').split('\n');
		}
		// const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\n') : [];

		const item = {
			type: 'table',
			raw: cap[0]!,
			header: [] as TableCell[],
			align: [] as ('cener' | 'left' | 'right' | null)[],
			rows: [] as TableCell[][],
			tokens: [] as NodesToken[]
		} as NodesToken;

		if (headers.length != aligns.length) {
			// header and align columns must be equal, rows can be different.
			return null;
		}

		for (const align of aligns) {
			if (this.rules!.other.tableAlignRight.test(align)) {
				item.align!.push('right');
			} else if (this.rules!.other.tableAlignCenter.test(align)) {
				item.align!.push('center');
			} else if (this.rules!.other.tableAlignLeft.test(align)) {
				item.align!.push('left');
			} else {
				item.align!.push(null);
			}
		}

		for (let i = 0; i < headers.length; i++) {
			item.header!.push({
				text: headers[i],
				tokens: this.lexer!.inline(headers[i], [] as NodesToken[]),
				header: true,
				align: item.align![i]
			} as TableCell);
		}

		for (const row of rows) {
			item.rows!.push(splitCells(row, item.header!.length).map((cell, i) => {
				return {
					text: cell,
					tokens: this.lexer!.inline(cell, [] as NodesToken[]),
					header: false,
					align: item.align![i]
				} as TableCell;
			}))
		}

		return item;
	}

	lheading(src : string) : NodesToken | null {
		const cap = this.rules!.block.lheading.exec(src);
		if (cap != null && cap[0] != null) {
			return {
				type: 'heading',
				raw: cap[0]!,
				depth: cap[2]!.charAt(0) == '=' ? 1 : 2,
				text: cap[1]!,
				tokens: this.lexer!.inline(cap[1]!, [] as NodesToken[]),
			} as NodesToken;
		}

		return null;
	}

	paragraph(src : string) : NodesToken | null {
		// console.log(this.rules!.block.paragraph);
		const cap = this.rules!.block.paragraph.exec(src);
		// console.log(this.rules!.block.paragraph);
		if (cap != null && cap[0] != null) {
			const text = cap[1]!.charAt(cap[1]!.length - 1) == '\n'
				? cap[1]!.slice(0, -1)
				: cap[1]!;

			return {
				type: 'paragraph',
				raw: cap[0]!,
				text,
				tokens: this.lexer!.inline(text, [] as NodesToken[]),
			} as NodesToken;
		}

		return null;
	}

	text(src : string) : NodesToken | null {
		const cap = this.rules!.block.text.exec(src);
		if (cap != null && cap[0] != null) {
			return {
				type: 'text',
				raw: cap[0]!,
				text: cap[0]!,
				tokens: this.lexer!.inline(cap[0]!, [] as NodesToken[])
			} as NodesToken
		}

		return null;
	}

	escape(src : string) : NodesToken | null {
		const cap = this.rules!.inline.escape.exec(src);
		if (cap != null && cap[0] != null) {
			return {
				type: 'escape',
				raw: cap[0]!,
				text: cap[1]!,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}
		return null;
	}

	tag(src : string) : NodesToken | null {
		const cap = this.rules!.inline.tag.exec(src);
		if (cap != null && cap[0] != null) {
			if (!this.lexer!.state.inLink && this.rules!.other.startATag.test(cap[0]!)) {
				this.lexer!.state.inLink = true;
			} else if (this.lexer!.state.inLink && this.rules!.other.endATag.test(cap[0]!)) {
				this.lexer!.state.inLink = false;
			}
			if (!this.lexer!.state.inRawBlock && this.rules!.other.startPreScriptTag.test(cap[0]!)) {
				this.lexer!.state.inRawBlock = true;
			} else if (this.lexer!.state.inRawBlock && this.rules!.other.endPreScriptTag.test(cap[0]!)) {
				this.lexer!.state.inRawBlock = false;
			}

			return {
				type: 'html',
				raw: cap[0]!,
				inLink: this.lexer!.state.inLink,
				inRawBlock: this.lexer!.state.inRawBlock,
				block: false,
				text: cap[0]!,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}

		return null;
	}

	link(src : string) : NodesToken | null {
		const cap = this.rules!.inline.link.exec(src);
		if (cap != null && cap[0] != null) {
			const trimmedUrl = cap[2]!.trim();
			if (this.options.pedantic == null && this.rules!.other.startAngleBracket.test(trimmedUrl)) {
				// commonmark requires matching angle brackets
				if (!this.rules!.other.endAngleBracket.test(trimmedUrl)) {
					return null;
				}

				// ending angle bracket cannot be escaped
				const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\', null);
				if ((trimmedUrl.length - rtrimSlash.length) % 2 == 0) {
					return null;
				}
			} else {
				// find closing parenthesis
				const lastParenIndex = findClosingBracket(cap[2]!, '()');
				if (lastParenIndex > -1) {
					const start = cap[0]!.indexOf('!') == 0 ? 5 : 4;
					const linkLen = start + cap[1]!.length + lastParenIndex;
					cap[2] = cap[2]!.substring(0, lastParenIndex);
					cap[0] = cap[0]!.substring(0, linkLen).trim();
					cap[3] = '';
				}
			}
			let href = cap[2]!;
			let title = '';
			if (this.options.pedantic == true) {
				// split pedantic href and title
				const link = this.rules!.other.pedanticHrefTitle.exec(href);
				if (link != null) {
					href = link[1]!;
					title = link[3]!;
				}
			} else {
				title = cap[3] != null ? cap[3]!.slice(1, -1) : '';
			}

			href = href.trim();
			if (this.rules!.other.startAngleBracket.test(href)) {
				if (this.options.pedantic == true && !this.rules!.other.endAngleBracket.test(trimmedUrl)) {
					// pedantic allows starting angle bracket without ending angle bracket
					href = href.slice(1);
				} else {
					href = href.slice(1, -1);
				}
			}
			return outputLink(cap as string[], {
				href: href.length > 0 ? href.replace(this.rules!.inline.anyPunctuation, '$1') : href,
				title: title.length > 0 ? title.replace(this.rules!.inline.anyPunctuation, '$1') : title,
				tokens: [] as NodesToken[]
			} as NodesToken, cap[0], this.lexer!, this.rules!);
		}

		return null;
	}

	reflink(src : string, links : Links) : NodesToken | null {
		let cap : string[] | null = null
		if (this.rules!.inline.reflink.exec(src) != null) {
			cap = this.rules!.inline.reflink.exec(src) as string[]
		}
		if (this.rules!.inline.nolink.exec(src) != null) {
			cap = this.rules!.inline.nolink.exec(src) as string[]
		}
		if (cap != null && cap[0] != null) {
			const linkString = (cap[2] ?? cap[1]).replace(this.rules!.other.multipleSpaceGlobal, ' ');
			// #ifndef APP-HARMONY
			const link = links[linkString.toLowerCase()];
			// #endif
			// #ifdef APP-HARMONY
			const link: any = links[linkString.toLowerCase()];
			// #endif
			if (link == null) {
				const text = cap[0]!.charAt(0);
				return {
					type: 'text',
					raw: text,
					text,
					tokens: [] as NodesToken[]
				} as NodesToken
			}
			return outputLink(cap, link as NodesToken, cap[0], this.lexer!, this.rules!);
		}

		return null;
	}

	emStrong(src : string, maskedSrc : string, prevChar?: string) : NodesToken | null {
		let match = this.rules!.inline.emStrongLDelim.exec(src);
		if (match == null) return null;
		prevChar = prevChar ?? '';

		// _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
		if (match.length >= 4 && match[3] != null && prevChar.match(this.rules!.other.unicodeAlphaNumeric) != null) return null;

		const nextChar = match[1] ?? match[2] ?? '';

		if ((nextChar == '') || (prevChar == null || prevChar == '') || this.rules!.inline.punctuation.exec(prevChar) != null) {
			// unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
			const lLength = ([...(match[0] as string)].length - 1) as number;
			let rDelim: any | null = lLength;
			let rLength = lLength;
			let delimTotal = lLength;
			let midDelimTotal = 0;

			const endReg = `${(match[0] as string)[0]}` == '*' ? this.rules!.inline.emStrongRDelimAst : this.rules!.inline.emStrongRDelimUnd;
			endReg.lastIndex = 0;

			// Clip maskedSrc to same section of string as src (move to lexer?)
			maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

			match = endReg.exec(maskedSrc);
			while (match != null) {
				rDelim = match[1] ?? match[2] ?? match[3] ?? match[4] ?? match[5] ?? match[6];

				if (rDelim == '' || rDelim == null) {
					match = endReg.exec(maskedSrc);
					continue; // skip single * in __abc*abc__
				}

				rLength = [...`${rDelim}`].length;

				if ((match[3] != null && `${match[3]}`.length > 0) || (match[4] != null && `${match[4]}`.length > 0)) {
					delimTotal += rLength;
					continue;
				} else if (match[5] != null || match[6] != null) {
					if (lLength % 3 > 0 && (lLength + rLength) % 3 == 0) {
						midDelimTotal += rLength;
						continue;
					}
				}

				delimTotal -= rLength;

				if (delimTotal > 0) {
					match = endReg.exec(maskedSrc);
					continue; // Haven't found enough closing delimiters
				}

				// Remove extra characters. *a*** -> *a*
				rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
				// char length can be >1 for unicode characters;
				const lastCharLength = `${[...(match[0] as string)][0]}`.length;
				const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);

				// Create `em` if smallest delimiter has odd char count. *a***
				if (Math.min(lLength, rLength) % 2 > 0) {
					const text = raw.slice(1, -1);
					return {
						type: 'em',
						raw,
						text: text,
						tokens: this.lexer!.inlineTokens(text, [] as NodesToken[]),
					} as NodesToken;
				}

				// Create 'strong' if smallest delimiter has even char count. **a***
				const text = raw.slice(2, -2);
				return {
					type: 'strong',
					raw,
					text: text,
					tokens: this.lexer!.inlineTokens(text, [] as NodesToken[]),
				} as NodesToken;
			}
		}

		return null;
	}

	codespan(src : string) : NodesToken | null {
		const cap = this.rules!.inline.code.exec(src);
		if (cap != null && cap[0] != null) {
			let text = `${cap[2]}`.replace(this.rules!.other.newLineCharGlobal, ' ');
			const hasNonSpaceChars = this.rules!.other.nonSpaceChar.test(text);
			const hasSpaceCharsOnBothEnds = this.rules!.other.startingSpaceChar.test(text) && this.rules!.other.endingSpaceChar.test(text);
			if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
				text = text.substring(1, text.length - 1);
			}
			return {
				type: 'codespan',
				raw: cap[0]!,
				text,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}

		return null;
	}

	br(src : string) : NodesToken | null {
		const cap = this.rules!.inline.br.exec(src);
		if (cap != null && cap[0] != null) {
			return {
				type: 'br',
				raw: cap[0]!,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}

		return null;
	}

	del(src : string) : NodesToken | null {
		const cap = (this.rules!.inline['del'] as RegExp).exec(src);
		if (cap != null && cap[0] != null) {
			return {
				type: 'del',
				raw: cap[0]!,
				text: cap[2]!,
				tokens: this.lexer!.inlineTokens(cap[2]!, [] as NodesToken[]),
			} as NodesToken;
		}

		return null;
	}

	autolink(src : string) : NodesToken | null {
		const cap = this.rules!.inline.autolink.exec(src);
		if (cap != null && cap[0] != null) {
			let text = '';
			let href = '';
			if (cap[2] == '@') {
				text = cap[1]!;
				href = `mailto:${text}`;
			} else {
				text = cap[1]!;
				href = text;
			}

			return {
				type: 'link',
				raw: cap[0]!,
				text,
				href,
				tokens: [
					{
						type: 'text',
						raw: text,
						text
					} as NodesToken
				] as NodesToken[],
			} as NodesToken;
		}

		return null;
	}

	url(src : string) : NodesToken | null {
		const cap = (this.rules!.inline.url as RegExp).exec(src);
		if (cap != null && cap[0] != null) {
			let text = '';
			let href = '';
			if (cap[2] == '@') {
				text = cap[0]!;
				href = `mailto:${text}`;
			} else {
				// do extended autolink path validation
				let prevCapZero : any | null = null;
				do {
					prevCapZero = cap[0];
					cap[0] = (this.rules!.inline._backpedal as RegExp).exec(cap[0]!)?.[0] ?? '';
				} while (prevCapZero != cap[0]);
				text = cap[0]!;
				if (cap[1] == 'www.') {
					href = `http://${text}`;
				} else {
					href = text;
				}
			}
			return {
				type: 'link',
				raw: cap[0]!,
				text,
				href,
				tokens: [
					{
						type: 'text',
						raw: text,
						text
					} as NodesToken
				] as NodesToken[],
			} as NodesToken;
		}

		return null;
	}

	inlineText(src : string) : NodesToken | null {
		const cap = this.rules!.inline.text.exec(src);
		if (cap != null && cap[0] != null) {
			const escaped = this.lexer!.state.inRawBlock;
			return {
				type: 'text',
				raw: cap[0]!,
				text: cap[0]!,
				escaped,
				tokens: [] as NodesToken[]
			} as NodesToken;
		}

		return null;
	}
}