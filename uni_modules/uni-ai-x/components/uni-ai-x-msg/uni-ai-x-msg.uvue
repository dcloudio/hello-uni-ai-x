<template>
	<view class="msg-types-item-root">
		<text v-if="msg.error_msg != null" class="error-msg">{{msg.error_msg}}</text>
		<template v-else v-for="node in markdownTokenList">
			<view v-if="node.type == 'hr'" class="hr"></view>
			<text v-else-if="node.type == 'paragraph'" class="paragraph">
				<uni-marked-el v-for="(token, tokenIndex) in node.tokens" :key="tokenIndex" :type="token.type" :token="token" />
			</text>
			<view v-else-if="node.type == 'blockquote'" class="blockquote">
				<uni-marked-el v-for="(token, tokenIndex) in node.tokens" :key="tokenIndex" :type="token.type" :token="token" />
			</view>
			<view v-else-if="node.type == 'code'" class="code-box">
				<uni-ai-msg-code :codeTokens="node.codeTokens ?? []" :codeText="node.text" :language="node.lang" />
			</view>
			<!-- 表格 -->
			<view v-else-if="node.type == 'table'" class="table-box">
				<view class="table-header">
					<template v-for="(cell, cellIndex) in node.header" :key="cellIndex">
						<text class="table-header-text">{{cell.text.replace(/\*/g, '')}}</text>
					</template>
				</view>
				<view class="table-body">
					<view v-for="(row, rowIndex) in node.rows" :key="rowIndex" class="table-body-row">
						<text class="table-body-text" v-for="(cell, cellIndex) in row" :key="cellIndex">
							{{cell.text.replace(/\*/g, '')}}
						</text>
					</view> 
				</view>
				<!-- <uni-table v-else-if="node.type == 'table'" :stripe="true" :height="500" :columns="getTableInfo(node)['columns']" :data="getTableInfo(node)['data']"></uni-table> -->
			</view>
			<view v-else style="width: 100%;flex-direction: row;">
				<uni-marked-el :token="node" :type="node.type" :depth="node.depth ?? 0" />
			</view>
		</template>
		<template v-if="isLastAiMsg && msg.body == ''">
			<text v-if="state == 'stop'" class="text stop">回答被终止</text>
			<text v-if="state == 'none'" class="needTry">错误：未回复</text>
			<uni-rotate-icon v-if="state == 'processing'" class="loging" />
		</template>
		<!-- <text style="color: red;border: solid 1px red;padding: 5px;border-radius: 5px;">markdown解析耗时：{{runTime}}ms</text> -->
	</view>
</template>

<script>
	import {uniAi, MsgItem} from '@/uni_modules/uni-ai-x/sdk'
	import {useMarked, TokensList, NodesToken as MarkdownToken, Link} from '@/uni_modules/kux-marked';
	import {IToken, parseCode, ParseCodeRes} from '@/uni_modules/uni-ai-x/components/uni-ai-msg-code/parseCode.uts'
	import {TableCell} from '@/uni_modules/kux-marked/utssdk/Tokens.interface.uts'
	const marked = useMarked();
	type TaskListItem = () => Promise<void>
	// import testMarkdownText from '../markdownText.uts';
	export default {
		name: 'msg-uni-ai',
		components: {},
		props: {
			msg: {
				type: Object as PropType<MsgItem>,
				required: true,
				default: {},
			}
		},
		data() {
			return {
				// 耗时
				runTime: 0,
				parseLock: false,
				markdownStrIndex: 0,
				taskList: [] as TaskListItem[],
				tmpTokenList: [] as MarkdownToken[]
			}
		},
		computed: {
			// 是否是自己发送的消息
			state(): string {
				return uniAi.currentChat!.state
			},
			isLastAiMsg(): boolean {
				return uniAi.lastAiMsg?._id == this.msg._id
			},
			markdownTokenList(): MarkdownToken[] {
				return [...this.msg.markdownTokenList, ...this.tmpTokenList]
			}
		},
		watch: {
			state: {
				handler(newVal: string, oldVal: string) {
					if ((newVal == 'stop' || newVal == 'completed') && oldVal == 'processing') {
						this.msg.markdownTokenList.push(...this.tmpTokenList)
						this.tmpTokenList = []
					}
				}
			},
			'msg.body': {
				async handler(msgBody: string) {	
					if (this.state == 'processing') {
						this.taskList.push(async () => {
							if (msgBody.length == 0){
								return
							}
							if (this.markdownStrIndex >= msgBody.length) {
								if (this.msg.markdownTokenList.length == 0) {
									// 这种情况是点击重新回答
									this.markdownStrIndex = 0
								} else {
									this.markdownStrIndex = 0
									console.error('意外超长，请检查')
									return
								}
							}
							await this.markdownParse(msgBody)
						})
						this.runTask()
					} else {
						// const testMd = ''
						// const TokensList = marked.lexer(testMd,null) as TokensList
						// this.msg.markdownTokenList = TokensList.tokens as MarkdownToken[]
						
						// console.log('this.msg.body', this.msg.body)
						// console.log('this.msg.markdownTokenList', this.msg.markdownTokenList)
					}
				},
				immediate: true
			}
		},
// 		mounted(){
// // 模拟ai 流式回答消息
// const text = `# 五级标题示例

// ## 二级标题
// ### 三级标题
// #### 四级标题
// ##### 五级标题

// ---

// ## 有序列表示例

// 1. 第一项
// 2. 第二项
//    1. 子项一
//    2. 子项二
// 3. 第三项

// ---

// ## 简单表格示例

// | 姓名 | 年龄 | 职业 |
// |------|------|------|
// | 张三 | 28   | 工程师 |
// | 李四 | 32   | 设计师 |
// | 王五 | 25   | 学生 |

// ---

// ## 简单JS代码示例

// \`\`\`javascript
// // 计算两个数的和
// function add(a, b) {
//   return a + b;
// }

// // 使用示例
// const result = add(5, 3);
// console.log(result); // 输出: 8
// \`\`\`

// ---

// ## 链接示例

// [访问百度](https://www.baidu.com)

// 或者直接显示URL：<https://www.baidu.com>`
// 			const textMarkdown = text
// 			uniAi.currentChat!.state = 'processing'
// 			this.msg.body = ''
// 			this.msg.markdownTokenList = []
// 			// 一个字一个字往 this.msg.body 上追加
// 			let i = 0
// 			let timer: number = 0
// 			timer = setInterval(() => {
// 				if (i >= textMarkdown.length) {
// 					clearInterval(timer)
// 				} else {
// 					this.msg.body += textMarkdown[i]
// 					i++
// 				}
// 			}, 10)
// 		},
		methods: {
			runTask(){
				if (this.parseLock == false && this.taskList.length > 0) {
					this.parseLock = true
					this.taskList[0]().finally(() => {
						this.taskList.shift()
						this.parseLock = false
						this.runTask()
					})
				}
			},
			// 根据不同类型，判断是否闭合
			isClose(type: string, markdownText: string): boolean {
				// 需要双换行闭合的类型
				const doubleNewlineTypes = ['list', 'table', 'code']
				// 需要单换行闭合的类型
				const singleNewlineTypes = ['paragraph', 'heading', 'hr', 'blockquote', 'def', 'space']
				// 不需要换行闭合的类型
				const noNewlineTypes = ['text', 'strong', 'em', 'del', 'link', 'image', 'codespan']
				if (doubleNewlineTypes.includes(type)) {
					return markdownText.includes('\n\n')
				} else if (singleNewlineTypes.includes(type)) {
					return markdownText.includes('\n')
				} else if (noNewlineTypes.includes(type)) {
					return markdownText.includes('\n') == false
				} else {
					// console.error('未找到闭合函数', type, markdownText)
					return false
				}
			},
			async parseCode(markdownText: string): Promise<string>{
				// 如果 lastToken 是代码块，并且包含 ``` (无序列表不完整时可能会被解析成代码块)，则不继续解析 markdown
				const codeToken: MarkdownToken | null = this.tmpTokenList.find(token => token.type == 'code') ?? null
				if (codeToken != null && codeToken.isClose != true && markdownText.split('\n').length > 1) {
					// 按行分割第 1 行是 ``` + lang，第 2 行起是代码内容
					const codeTokenArr = markdownText.split('\n')
					// console.error('codeTokenArr', codeTokenArr)
					const lang = codeTokenArr[0].slice(3)
					// 去掉首行和末行的 ```
					const codeText = codeTokenArr.slice(1).join('\n').slice(0, -5)
					// 末尾必须是换行符
					if (markdownText.slice(-1) != '\n') {
						if (codeToken.codeTokens == null) {
							codeToken.text = codeText
						}
						// console.error('末尾必须是换行符')
						return ''
					}
					// console.error('codeText', codeText,'\n\n\n lang', lang, '\n\n\n markdownText', markdownText)
					codeToken.text = codeText
					// console.error('codeText', codeText, lang)
					if (lang != 'markdown') {
						const parseCodeRes = await parseCode(codeText,lang)
						const codeTokens = parseCodeRes.tokens
						if (parseCodeRes.error != null) {
							// console.log('解析代码失败',parseCodeRes.error, codeText, lang)
						} else {
							// console.error('codeTokens--------------',codeTokens, codeText, lang)
							codeToken.codeTokens = codeTokens
						}
					}
					// 拿到所有包含 ``` 的行
					const codeBorderLines = codeTokenArr.filter(line => line.includes('```'))
					// 如果 ``` 的行数小于 2，则不继续解析 markdown
					if (codeBorderLines.length < 2) {
						// console.error('代码还没结束',codeBorderLines.length, codeTokenArr)
						return ''
					}
					// 如果 代码开始和结束标识 不相等，则不继续解析 markdown
					// 统计结束标识的行数
					const codeEndIndex = codeBorderLines.filter(line => line == '```').length
					// 统计开始标识的行数
					const codeStartIndex = codeBorderLines.length - codeEndIndex
					if (codeStartIndex != codeEndIndex) {
						// console.error('代码开始和结束标识 不相等',codeStartIndex, codeEndIndex)
						return ''
					} else {
						// 闭合代码块
						codeToken.isClose = true
						this.msg.markdownTokenList.push(codeToken)
						this.tmpTokenList = []
						this.markdownStrIndex += markdownText.lastIndexOf('```') + 3
						return ''
					}
				}
				return markdownText
			},
			async markdownParse(markdownText: string){
				// 拿到本次解析的文本
				markdownText = markdownText.slice(this.markdownStrIndex)
				// console.log('markdownText111========>',markdownText)
				markdownText = await this.parseCode(markdownText)
				if (markdownText.length == 0) {
					// console.error('空了，不继续执行',markdownText)
					return
				}
				let newTokenList: MarkdownToken[] = []
				try {
					newTokenList = (marked.lexer(markdownText,null) as TokensList).tokens as MarkdownToken[]
				} catch (error) {
					/*
					 拦截部分场景下 marked 解析器出错的情况。
					 已知问题：
					 	1. Android 端，链接的 markdown 不完整时，会报错。但不影响整个流式解析逻辑。
					*/
					console.warn('markdownParse error',error)
					return
				}
				
				// 新增的元素是否闭合
				newTokenList[0]!.isClose = this.isClose(newTokenList[0]!.type ?? '', markdownText)
				// 解析结果为闭合的，则直接添加到 msg.markdownTokenList 中，否则添加到临时列表中
				if (newTokenList[0].isClose == true) {
					this.tmpTokenList = []
					this.msg.markdownTokenList.push(newTokenList[0]!)
					this.markdownStrIndex += newTokenList[0]!.raw!.length
					// 尝试合并后两项，如果合并成功，则删除后两项，并添加合并后的元素
					const mdTLLength = this.msg.markdownTokenList.length
					if (mdTLLength > 1 && newTokenList[0].type == 'paragraph') {
						const newMdText = this.msg.markdownTokenList[mdTLLength - 2]!.raw! + this.msg.markdownTokenList[mdTLLength - 1]!.raw!
						const newTokenList2 = (marked.lexer(newMdText,null) as TokensList).tokens as MarkdownToken[]
						if (newTokenList2.length == 1 && newTokenList2[0]!.type != newTokenList[0].type){
							this.msg.markdownTokenList.splice(-2)
							this.msg.markdownTokenList.push(newTokenList2[0]!)
						}
					}
				} else {
					this.tmpTokenList = newTokenList
				}
			},
			// getTableInfo(node: MarkdownToken): UTSJSONObject {
			// 	const columns: UTSJSONObject[] = []
			// 	node.header?.forEach((cell: TableCell) => {
			// 		columns.push({
			// 			dataKey: cell.text,
			// 			title: cell.text,
			// 			align: cell.align ?? 'left'
			// 		})
			// 	})
			// 	const data: UTSJSONObject[] = []
			// 	node.rows?.forEach((row: TableCell[]) => {
			// 		const rowData: UTSJSONObject = {}
			// 		row.forEach((cell: TableCell, index: number) => {
			// 			rowData[columns![index]!.dataKey!] = cell.text
			// 		})
			// 		data.push(rowData)
			// 	})
			// 	// console.error('columns' + JSON.stringify(columns))
			// 	// console.error('table data',JSON.stringify(data))
			// 	return {
			// 		columns,
			// 		data
			// 	}
			// }
		}
	}
</script>

<style lang="scss">
	.msg-types-item-root {
		flex-direction: row;
		flex-wrap: wrap;
		flex: 1;
		background-color: #fff;
		border-radius: 8px;
		// #ifdef WEB
		user-select: text;
		// #endif

		.error-msg {
			color: #ff4d4f;
			font-size: 14px;
			line-height: 26px;
		}
		.paragraph {
			width: 100%;
			.text {
				// 自动换行
				white-space: normal;
				/* #ifndef APP */
				max-width: 100%;
				word-break: break-all;
				/* #endif */
			}
		}
		
		.blockquote {
			padding-left: 5px;
			background: #f5f5f5;
			border-left: 4px solid #ddd;
			width: 100%;
		}
		
		.code-box {
			width: 100%;
		}

		.table-box {
			width: 100%;
			border: solid 1px #ddd;
			border-style: solid solid none none;
			margin: 5px 0;
			.table-header {
				flex-direction: row;
				.table-header-text {
					font-weight: bold;
					font-size: 16px;
				}
			}
			.table-body {
				flex-direction: column;
				.table-body-row {
					flex-direction: row;
				}
			}
			.table-header-text, .table-body-text {
				border: solid 1px #ddd;
				border-style: none none solid solid;
				text-align: center;
				line-height: 35px;
				flex: 1;
			}
		}

		.hr {
			height: 1px;
			background-color: #ddd;
			margin: 10px 0;
			width: 100%;
		}
		
		.text {
			color: #333;
			// line-height: 1.5;
			white-space: normal;
			/* #ifndef APP */
			word-break: break-all;
			/* #endif */
			&.stop {
				color: #999;
			}
		}
		
		.loging {
			padding-top: 8px;
		}
		
		.needTry {
			color: #ff4d4f;
			font-size: 14px;
			text-align: center;
			padding: 10px;
		}
	}
	.ui-theme-dark {
		.msg-types-item-root {
			.paragraph .text{
				color: #fff !important;
			}
			.blockquote {
				background-color: #3c3c3c !important;
				.text {
					color: #fff !important;
				}
			}
			
		}
	}
</style>