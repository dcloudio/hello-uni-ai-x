import uniAi from '@/uni_modules/uni-ai-x/sdk';

// 类型定义区
type SsePayloadAction = "message" | "end";
type SsePayloadChannel = "UNI_CLOUD_SSE";

type SsePayload = {
    action: SsePayloadAction;
    channel: SsePayloadChannel;
    message?: string | UniCloudError;
    messageId: number;
    seqId: string;
};

export type OnSSeMsgFn = (content: string, seqId: string) => void;

// 常量定义
const DEFAULT_TIMEOUT = 100;
const INITIAL_MESSAGE_ID = -1;

class UniCloudSse {
    msgQueueMap = new Map<string, Map<number, SsePayload>>();
    lastProcessedIdMap = new Map<string, number>();
    OnSSeMsgFnList: OnSSeMsgFn[] = [];
    processingMap = new Map<string, boolean>();
    timeoutT = DEFAULT_TIMEOUT;

    constructor() {
        uni.onPushMessage(this._onPushMsg);
    }

    private _onPushMsg = (res: OnPushMessageCallbackResult): void => {
				console.log('云函数推送消息', res);
        let payload: SsePayload | null = null;
        
        // #ifdef WEB
        if (res.data.payload != null) {
            payload = res.data.payload as SsePayload;
        }
        // #endif
        
        // #ifndef WEB
        payload = JSON.parse<SsePayload>(JSON.stringify(res.data.payload))!
        // #endif
        if (payload == null || payload.channel != "UNI_CLOUD_SSE") {
          return
        }

        this.handleSsePayload(payload);
    }

    private handleSsePayload(payload: SsePayload): void {
        const seqId = payload.seqId;
        
        if (!this.msgQueueMap.has(seqId)) {
            this.msgQueueMap.set(seqId, new Map<number, SsePayload>());
            this.lastProcessedIdMap.set(seqId, INITIAL_MESSAGE_ID);
        }

        const queue = this.msgQueueMap.get(seqId)!;
        queue.set(payload.messageId, payload);

        if (this.processingMap.get(seqId) != true) {
            this.processMessages(seqId);
        }
    }

    private async processMessages(seqId: string): Promise<void> {
        this.processingMap.set(seqId, true);
        
        try {
            const queue = this.msgQueueMap.get(seqId);
            if (queue == null) return;

            let lastProcessedId = this.lastProcessedIdMap.get(seqId) ?? INITIAL_MESSAGE_ID;
            let nextMessageId = lastProcessedId + 1;

            while (queue.has(nextMessageId)) {
                const sseMsgItem = queue.get(nextMessageId);
                if (sseMsgItem == null) break;
                
                lastProcessedId = sseMsgItem.messageId;
                this.lastProcessedIdMap.set(seqId, lastProcessedId);
                
                await this.processSingleMessage(sseMsgItem);
                queue.delete(nextMessageId);
                nextMessageId++;
            }
        } finally {
            this.processingMap.set(seqId, false);
        }
    }

    private async processSingleMessage(ssePayload: SsePayload): Promise<void> {
        if (uniAi.currentChat!.state == 'stop') {
            this.clearData(ssePayload.seqId);
            return;
        }

        if (ssePayload.action == "end") {
            this.clearData(ssePayload.seqId);
            uniAi.currentChat!.state = 'completed';
            this.timeoutT = 0;
            return;
        }

        this.timeoutT = DEFAULT_TIMEOUT;

        if (ssePayload.message == null) return;

        if (typeof ssePayload.message != 'string') {
            this.handleError(ssePayload.message as UniCloudError);
            return;
        }

        await this.emitMessageInChunks(ssePayload.message, ssePayload.seqId);
    }

    private handleError(error: UniCloudError): void {
        console.error('云函数错误', error);
        uni.showModal({
            content: error.errMsg,
        });
    }

    private async emitMessageInChunks(message: string, seqId: string): Promise<void> {
        for (let i = 0; i < message.length; i++) {
            const chunk = message.charAt(i);
            this.emitMsg(chunk, seqId);
            
            if (this.timeoutT > 0) {
                await new Promise<void>(resolve => {
									setTimeout(()=> resolve(), this.timeoutT)
								});
            }
        }
    }

    private clearData(seqId: string): void {
        this.msgQueueMap.delete(seqId);
        this.lastProcessedIdMap.delete(seqId);
        this.processingMap.delete(seqId);
    }

    private emitMsg(content: string, seqId: string): void {
        this.OnSSeMsgFnList.forEach((fn) => {
            try {
                fn(content, seqId);
            } catch (e) {
                console.error('Error in message handler:', e);
            }
        });
    }

    onMsg(fn: OnSSeMsgFn): void {
        this.OnSSeMsgFnList.push(fn);
    }

    offMsg(fn: OnSSeMsgFn): void {
        const index = this.OnSSeMsgFnList.indexOf(fn);
        if (index >= 0) {
            this.OnSSeMsgFnList.splice(index, 1);
        }
    }
}

const uniCloudSse = new UniCloudSse();
export default uniCloudSse;
export { uniCloudSse};